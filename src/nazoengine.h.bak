#pragma once

#include <filesystem>
#include <functional>
#include <iostream>
#include <map>
#include <sstream>

#include <glog/logging.h>
#include <fmt/format.h>

struct Engine;
struct Node {
  Engine* engine;
  std::string name;
  Node* evaluated = nullptr;
  Node* lhs = nullptr;
  Node* rhs = nullptr;
  int nary = 0;
  std::function<Node*(Engine*, Node*)> apply;
  std::function<std::string(const Node*, bool)> custom_repr;
  bool is_list = false;
  int id;

  Node(const Node& o) : engine(o.engine), name(o.name), evaluated(o.evaluated), apply(o.apply) { create_node(); }
  Node(Engine* engine_) : engine(engine_),  name("Node") { create_node(); }
  Node(const std::string& name_, Engine* engine_, std::function<Node*(Engine*, Node*)> apply_, std::function<std::string(const Node*, bool)> custom_repr_ = nullptr, bool is_list_ = false) : engine(engine_), name(name_), apply(apply_), custom_repr(custom_repr_), is_list(is_list_) { create_node(); }
  virtual ~Node() {}

  void create_node();

  // evaluate the leftmost unevaluated thunk.
  // @return nullptr: did not evaluate. otherwise: evaluated.
  virtual Node* eval_step(bool* progress = nullptr) { return this; }

  // evaluate as far as possible
  virtual Node* eval() { return evaluated ? evaluated : this; }
  virtual bool is_valid() const { return true; }

  virtual Node* clone() {
    return new Node(*this);
  }
  void print() const { std::cout << name << std::endl; }
  virtual std::string repr(bool with_brackets) const {
    return custom_repr ? custom_repr(this, with_brackets) : name;
  }
  std::string repr_dot() const {
    std::ostringstream oss;
    oss << "digraph nodes {" << std::endl;;
    repr_dot_impl(oss, this, "");
    oss << "}" << std::endl;
    return oss.str();
  }
  virtual void repr_dot_impl(std::ostream& os, const Node* parent, std::string label_name) const {
    os << "\"" << fmt::format("{}<{}>", parent->name, uintptr_t(parent)) << "\" -> \"" << fmt::format("{}<{}>", name, uintptr_t(this)) << "\"";
    if (!label_name.empty()) {
      os << "[ label = \"" + label_name + "\" ]";
    }
    os << ";" << std::endl;
  }
  virtual std::string get_name() const { return name; }
};
using ApplyFunc = std::function<Node*(Engine*, Node*)>;

// rootから左優先でap数がary数を満たしている場合に置換を実行する
bool eval_step(Node** root);

struct symbol final : public Node {
  Node* body = nullptr;
  symbol(const symbol& o) = delete;
  symbol(Engine* engine_) : Node(engine_) {
    name = "you_should_not_see_this"; // expect to be overwritten
  }
  void set_body(Node* body_) {
    body = body_;
  }
  Node* eval() override {
    if (!evaluated) {
      evaluated = body;
    }
    if (evaluated) {
      while (true) {
        if (auto reevaluated = evaluated->eval(); reevaluated != evaluated) {
          evaluated = reevaluated;
        } else {
          return evaluated;
        }
      }
    }
    return this;
  }
};

struct Engine {
  std::map<std::string, std::tuple<int, ApplyFunc, bool>> builtins;
  std::map<std::string, std::pair<std::string /* help */, std::function<void(Engine*, std::vector<std::string>)>>> special_commands; // starts with "%". (engine, tokens)
  std::map<std::string, symbol*> table;
  std::function<std::string(std::string_view)> sendrecv_func;
  bool verbose = false;
  bool list_repr = false;
  std::ostream *output = nullptr;

  // performance info.
  struct PerformanceSnapshot {
    std::chrono::system_clock::time_point tbegin;
    std::chrono::system_clock::time_point tend;
    size_t n_eval = 0;
    size_t n_create_node = 0;
    Engine* engine = nullptr;
    void stop() {
      n_eval = engine->n_eval - n_eval_begin;
      n_create_node = engine->n_create_node - n_create_node_begin;
      tend = std::chrono::system_clock::now();
    }
    double elapsed_us() {
      return std::chrono::duration_cast<std::chrono::nanoseconds>(tend - tbegin).count() * 1e-3;
    }
  private:
    size_t n_eval_begin = 0;
    size_t n_create_node_begin = 0;
    PerformanceSnapshot() {}
    friend struct Engine;
  };
  size_t n_eval = 0;
  size_t n_create_node = 0;

  Engine();

  PerformanceSnapshot start_performance_snapshot() {
    PerformanceSnapshot ps;
    ps.tend = ps.tbegin = std::chrono::system_clock::now();
    ps.n_eval_begin = n_eval;
    ps.n_create_node_begin = n_create_node;
    ps.engine = this;
    return ps;
  }

  void set_sendrecv_func(std::function<std::string(std::string_view)> sendrecv_func_) {
    sendrecv_func = sendrecv_func_;
  }
  std::string send_recv(std::string_view send_text) {
    if (sendrecv_func) {
      return sendrecv_func(send_text);
    }
    LOG(ERROR) << "call set_sendrecv_func()!";
    return "00";
  }

  symbol* def(const std::string& name, Node* body) {
    auto it = table.find(name);
    symbol* func = nullptr;
    if (it != table.end()) {
      if (it->second->evaluated) {
        std::cerr << "OVERWRITE SYMBOL BODY " << name << std::endl;
        it->second->evaluated = nullptr;
      }
      func = it->second;
    } else {
      func = new symbol(this);
    }
    func->name = name;
    func->set_body(body);
    if (body && name != "pwr2" && name != "checkerboard") {
      if (verbose) std::cerr << "DEFINED [" << name << "] with a body" << std::endl;
    }
    table[name] = func;
    return func;
  }
  symbol* resolve(const std::string& name) {
    auto it = table.find(name);
    if (it != table.end()) {
      // already registered (with or without body).
      return it->second;
    }
    // placeholder.
    return def(name, nullptr);
  }

  void reset_output_stream() { output = &std::cout; }
  void set_output_stream(std::ostream& os) { output = &os; }

  Node* parse_expr_with_locals(const std::string& nazogengo_text_code, std::map<std::string, Node*>&& local_nodes); // expression
  Node* parse_expr(const std::string& nazogengo_text_code) {
    return parse_expr_with_locals(nazogengo_text_code, {});
  }

  void parse_statement(std::string stmt); // single line 
  void parse_code(std::string code); // multiple lines

  Node* create_op_with_locals(const std::string& name, const std::map<std::string, Node*>& local_nodes);
  Node* create_op(const std::string& name) { return create_op_with_locals(name, {}); }

  void repl();

  void special_list(std::vector<std::string> args);
  void special_load(std::vector<std::string> args);
  void special_perf(std::vector<std::string> args);
  void special_interact(std::vector<std::string> args);
};

std::vector<std::filesystem::path> enumerate_text_files(std::vector<std::filesystem::path> search_paths);

struct define_global_symbol {
  define_global_symbol(std::string name, int nary, ApplyFunc apply, bool is_list = false) {
    defs[name] = {nary, apply, is_list};
  }
  static void define(Engine* engine) {
    engine->builtins = defs;
  }
  static std::map<std::string, std::tuple<int /*ary*/, ApplyFunc, bool /*is_list*/>> defs;
};
